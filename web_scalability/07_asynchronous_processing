-----------------------------------------------------------------------------
| CHAPTER 7 - ASYNCHRONOUS PROCESSING                                       |
-----------------------------------------------------------------------------

- Core Concepts

    - Synchronous = caller waits for result before continuing
      Asynchronous = caller continues without waiting for result


    - The results of an asynchronous call can be consumed by the caller using callbacks.  In this case,
        the caller doesn't block while waiting for the result, but provides a mechanism to be 
        notified once the operation is finished.


    - Using AJAX in JavaScript is one of the most common examples of using callbacks.  You declare a
        callback function when sending a request, and it is automatically invoked when the result is
        returned.

      JS's anonymous functions capture the scope in which they are declared, which makes callbacks
        easy to declare in a concise way.

        emailService.sendEmail(message, function(error){
            if(error){
                messageRow.markAsFailed(error);
            } else {
                messageRow.markAsDelivered();
            }
        });

      JS is only running a single thread of execution, but the JS event loop allows us to "emulate"
        parallel processing.  This provides a much better UX.


    - Blocking = You code has to wait for an external operation to finish.

      Blocking I/O = Blocking input/output, waiting for hard drive, network connection, etc.
                       (Ex: opening a TCP connection to a remote server)

      Nonblocking I/O = I/O operations that do not block the client code's execution
                          (You always provide a callback function)



- Shopping Analogy

    - Synchronous = going to the grocery store, and shopping for all of your products, one at a time

    - Asynchronous = shopping online, waiting for packages to arrive, you handle each package as they
                       come in



- Message Queues

    - A 'message queue' is a component that buffers and distributes asynchronous requests.  Messages
        are created by the message producers, buffered by the message queue, and delivered to
        message consumers.

    - Producers and consumers are coupled only by the message format and message queue location.

    - Standard platform-independent formats like XML or JSON are good choices for message formats.
        It's a good idea to validate the messages you receive strictly.



- Message Broker

    - Can be implemented in many different ways, from a component backed by a SQL database (as many
        home-grown queues are) or it could be a dedicated message broker that takes care of 
        accepting, routing, persisting, and delivering messages.  It could be a simple thread 
        running in the same application process.


    - If the message queue has more responsiblities (ie permission control, routing, failure recovery),
        it is often implemented as an independent application.  In such a case, we refer to it as
        a 'message broker'.

    
    - A message broker:

        - Specialized application designed for fast and flexible message queuing, routing, and delivery. 

        - The more sophisticated way of implementing message queues.

        - Usually provides specialized functionality out of the box.

        - Optimized for high concurrency and high throughput, because being able to enqueue messages fast 
            is one of their key responsibilities. 

        - May be referred to as message-oriented middleware (MOM) or enterprise service bus (ESB), 
            depending on the technology used.



- Message Consumers

    - The 2 most common ways of implementing consumers are:

        1. cron-like
        2. daemon-like


    - A 'cron-like consumer' connects periodically to the queue and checks the status of the queue.
        If there are messages, it consumes them and stops when the queue is empty.

      This is also called a 'pull model', since the consumer pulls messages from the queue.


    - A 'daemon-like consumer' runs constantly in an infinite loop, and usually has a permanent 
        connection to the message broker.  Instead of checking periodically, it simply blocks on the
        socket read operation.

      This is also called a 'push model', since messages are pushed by the message broker onto the 
        consumer as fast as the consumer can process them.


    - There are 3 common routing methods used, usually depending on the message broker you are using.
        They are:

        1. Direct worker queue
        2. Publish/Subscribe
        3. Custom routing rules



- Direct Worker Queue Method

    - In this method, consumers and producers only need to know the name of the queue.  There can be
        any number of producers and consumers, and a single queue.

      This routing method is well suited for the distribution of time-consuming tasks.


    - If the consumers are stateless and uniform, replacement of failed nodes is easy, and scaling
        becomes trivial.  

    - Common examples include sending out emails, processing videos, resizing images, or uploading
        content to third-party services.



- Publish/Subscribe Method

    - Messages are published to a topic, rather than a queue.  Each consumer subscribed to the topic
        gets the messages.

    - Consumers subscribe to the topic, then when a message is received, it is cloned for each
        consumer and put into that consumer's private queue.

    - For example, a message is published to a topic every time a purchase is confirmed.  Then we
        have several consumer services, one which notifies shipping providers, and a different one
        that processes loyalty program rules, etc.

    - This way, you can add more functionality without having to change existing producers or 
        consumers at all.

    - This flexible pattern of messaging is a variant of the commonly used Observer pattern,
        which decouples components and promotes the open/closed principle.



- Custom Routing Rules

    - Some message brokers support custom routing, where a consumer can decide in more flexible way
        which messages should be routed to it's queue (ie with pattern matching).


    - Logging and alerting are good examples of custom routing based on pattern matching.  You could
        create a 'Logger Queue' that accepts all log messages, and an 'Alert Queue' that accepts all
        critical errors.

      Then, you could have a file logger that simply writes all messages from 'Logger Queue' to a file.



- Messaging Protocols

    - Protocols can be binary or text-based, and can specify just minimal functionality, or they can
        describe hundreds of features in detail.


    - AMQP (Advanced Message Queueing Protocol)

        - Well-defined contract for publishing, industry standard
        - Has lots of features in protocol spec (ie reliability, delivery guarantees, transactions)
        - Most programming languages have clients


    - STOMP (Streaming Text-Oriented Messaging Protocol)

        - Very minimalist, small libraries, fewer than a dozen operations
        - Stateless text protocol similar to HTTP
        - Problems with interoperability


    - JMS (Java Message Service)

        - Java messaging standard widely adopted across libraries and Java application servers
        - Only runs on and integrates well with JVM



- Messaging Infrastructure

    - If you require throughput of thousands or tens of thousands of messages per second, RabbitMQ
        or ActiveMQ should work fine out of the box.

      If you need hundreds of thousands, you'll likely need custom sharding mechanisms and multiple
        broker instances.


    - Important Metrics to Consider

        1. Number of messages published per s

        2. Average message size

        3. Number of messages consumed per s

        4. Number of concurrent publishers

        5. Number of concurrent consumers

        6. If message persistence is needed

        7. If message acknowledgment is needed (so messages aren't lost in consumer crash)



- Benefits of Message Queues

    - One of the benefits of message queues is that they enable asynchronous processing.  We can defer
        time-consuming tasks without blocking our clients.


    - Good use cases of this asynchronous approach:

        - Interacting with remote servers
        - Low-value processing in the critical path (non-essential functions)
        - Resource intensive work (optimize for CPU, memory, I/O, etc.)


    - Another benefit is that message queues make for easier scalability.  Since queue workers
        consuming messages don't share state, they are easy to scale out.

    - Message queues allow you to transparently even out traffic spikes.  You can keep receiving
        requests, even in a time of increased traffic.

    - Isolating producers from consumers make our system more robust and fault tolerant.  Producers
        are not affected by consumer failures, and consumers are not affected by producer failures.

    - We should always try to create publishers that don't care who is consuming their messages or how.



- Message Queue Challenge - No Message Ordering

    - At scale, message ordering is not guaranteed.  For instance, you may get the 'Create Welcome Email'
        message before you get the 'Create User' message.  There are 2 concurrently running message
        consumers, and this is a classic race condition.


    - Also, one of the consumers might fail while processing a message, and would need to be
        re-enqueued.  Re-enqueueing a message is a strategy used by many message brokers, as it is
        assumed that a message hasn't been fully processed if it wasn't acknowledged by a consumer.

      And if we do re-enqueue it, there is no guarantee the previous consumer didn't resume processing.


    - Common ways to solve the ordering problem:

        1. Limit the number of consumers to a single thread per queue.

        2. Build the system to assume that messages can arrive in random order.

        3. Use a message broker that supports partial message ordering guarantees.


    - It is best to depend on the message broker to deliver messages in the right order using a
        partial message guarantee (ActiveMQ) or topic partitioning (Kafka).

      In ActiveMQ, this means that all messages with the same GroupId are delivered to the same
        consumer.  This way, ordering is guaranteed for that GroupId.



- Other Message Queue Challenges

    - Dealing the problem of message enqueueing can be easy or hard, depending on the application 
        needs.  If you can create idempotent consumers and use at-least-once semantics, your application 
        will be much simpler and more robust than with exactly-once.

      Sometimes, this is not possible, though.


    - Workflows with work broken down into small chunks are prone to race conditions.  You could
        describe this as 'programming without a call stack'.  


    - Systems built as hybrids of traditional imperative and message-oriented code can become more
        complex because their message flow is not explicitly declared anywhere.



- Message Queue Anti-Patterns

    - Don't treat the message queue like a TCP socket.  Some brokers allow you to have return channels,
        but avoid having an architecture where you send requests and wait for responses.
 
    - Don't treat the message queue like a database.  You should not allow deleting or updating 
        messages.

    - Avoid coupling producers with consumers.  Don't hardcode class names or make assumptions about
        how the message will be consumed when publishing.  Treat the message format as a contract.

    - You should be able to handle malformed messages and failures.  Don't assume the messages you
        receive are always valid.  You can put failed messages in a dead letter queue so that they
        can be reviewed or simply discard them.

