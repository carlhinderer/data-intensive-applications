--------------------------------------------------------------------
| 9. FOUNDATIONS                                                   |
--------------------------------------------------------------------

- Fundamental Pattern #1: Big Ball of Mud

    - The absence of any discernable architectural structure
    - Unregulated growth and expedient repair
    - Problems in deployment, testability, scalability, performance


- Fundamental Pattern #2: Unitary Architecture

    - Originally, from the mainframe days, all software ran on a single computer
    - Today only typically seen in embedded systems and other highly constrained environments


- Fundamental Pattern #3: Client-Server

    - 2-tier architecture with several flavors over time
    - Flavor A: Desktop application that connects to a DB server
    - Flavor B: Web browser with web server (2-tier even though web server and DB might be separate)
    - Flavor C: 3-Tier (Industrial grade DB server, application server, client with JavaScript)

    - Java was created during the rise of the 3-tier architecture.  C++ (the dominant 
        language at the time) developers complained about how difficult it was to move objects 
        over the network in a consistent way between systems.  So Java built 'serialization' right
        into the language, providing a 'serialization' interface for each object.  This is rarely
        used today, and does cause some backwards compatibility issues.


- Common Monolithic and Distributed Patterns

    [Monolithic = single deployment unit of all code]

    1. Layered architecture
    2. Pipeline architecture
    3. Microkernel architecture

    [Distributed = multiple deployments connected through remote access protocols]

    1. Service-based architecture
    2. Event-driven architecture
    3. Space-based architecture
    4. Service-oriented architecture
    5. Microservices architecture


- The Fallacies of Distributed Computing

    1. The network is reliable.
         - Timeouts and circuit breakers are used to mitigate issues

    2. Latency is zero.
         - Should look at mean, and also extremes of response times

    3. Bandwidth is infinite.
         - Need to think carefully about how much data to return with responses

    4. The network is secure.

    5. The topology never changes.
         - Architects have to be in constant contact with admins and operations

    6. There is only one administrator.

    7. Transport cost is zero.

    8. The network is homogeneous.


- Other Distributed Considerations

    - Distributed logging
        - Logging consolidation tools like Splunk can help with this

    - Distributed transactions
        - ACID is not possible
        - Eventual consistency
        - High performance, scalability, availability at the expense of data integrity and consistency
        - Transactional sagas utilize event sourcing to manage the state of a transaction
        - BASE transactions (Basic Availability, Soft state, Eventual consistency)

    - Contract maintenance and versioning





--------------------------------------------------------------------
| 10. LAYERED ARCHITECTURE STYLE                                   |
--------------------------------------------------------------------

- This is the de facto style for most applications due to simplicity, familiarity, low cost

- Follows Conway's Law, since most organizations consist of
    - UI developers
    - Backend developers
    - Rules developers
    - DBAs

- 'Accidental architecture' anti-pattern

- Typical Layers
    - Presentation Layer
    - Business Layer
    - Persistence Layer
    - Database Layer

- Technically partitioned, rather than domain partitioned
- Allows developers to leverage their particular technical expertise
- Lack of overall agility to respond to change

- Each layer can be replaced without affecting other layers, if there are well-defined contracts

- Open vs Closed - If the layers are closed, flow must go through each layer 
                     (layers cant be skipped)

- 'Architectural Sinkhole' anti-pattern = requests move through layers as pass-throughs without
     any business logic performed in each layer

- Strengths:
    - Good for small, simple applications
    - Good starting point
    - Low cost, simple, familiar
    - Ease of development
    - Lack of network traffic and latency

- Weaknesses:
    - Gets unruly as it gets bigger
    - Maintainability
    - Testability, need to mock and stub components all over the place
    - Agility
    - High-risk, infrequent deployments
    - Not elastic or scalable
    - Not fault-tolerant





--------------------------------------------------------------------
| 11. PIPELINE ARCHITECTURE STYLE                                  |
--------------------------------------------------------------------

- Best known as the underlying principle behind Unix shell languages like Bash and zsh

- Tools like MapReduce also use this style

- Quanta=1, since it is usually deployed as a monolith

- Pipes = unidirectional communication channels between filters
- Filters = self-contained, stateless, perform a single task

- 4 Types of Filters

    1. Producer = starting point (aka source)
    2. Transformer = transforms data and forwards it (aka map)
    3. Tester = accepts input and produces output based on test criteria (aka reduce)
    4. Consumer = termination point, may persist to database or display results on UI

- Unidirectional nature and simplicity encourage compositional reuse

- ETL tools leverage the pipeline architecture


- Example - Service Telemetry Information Sent From Services via streaming to Kafka

      Kafka  ->  Service Info Capture  ->  Duration Filter  ->  Uptime Filter  ->  End
      Topic           (producer)               (tester)             (tester)
                (subscribes to Kafka Topic)       |                    |
                                                  v                    v
                                        Duration Calculator     Uptime Calculator
                                            (transformer)         (transformer)
                                                      |            |
                                                      v            v
                                                     Database Output
                                                        (consumer)
                                                             |
                                                             v
                                                          MongoDB


- Strengths:
    - Simple and easy to understand, low cost
    - Lack of network traffic

- Weaknesses:
    - Still a monolith so deploying and testing are difficult
    - Not scalable or elastic
    - Not fault tolerant





--------------------------------------------------------------------
| 12. MICROKERNEL ARCHITECTURE STYLE                               |
--------------------------------------------------------------------

- Two simple architecture components: a core system and plug-in components

- Example
    - Core System = Eclipse IDE
    - Plug-ins = Eclipse plug-ins

- Keep components separate from the main processing flow.  To add a new component,
    all you have to do is plug in the new component and add it to the registry.

- Plug-in components are standalone, independent components that contain specialized
    processing, additional features, and custom code meant to enhance or extend the core
    system.

- Plug-ins should be independent of each other and ideally not have dependencies between
    them.

- Provides good component decoupling, allows for runtime changes, allows for
    asynchronous communication (good for UI responsiveness).  Makes deployment difficult
    while still having the problems of a monolith, and relies too much on the core system,
    though.

- If a plug-in needs access to the core system's database, it should access the data via
    the core system through an API.  However, a plug-in may also have it's own data store,
    either internal or external.

- A plug-in registry contains information about each plug-in module, including it's name,
    data contract, and remote access protocol details.  The registry could be as simple as 
    an internal dictionary or as complex as an external system like Apache ZooKeeper.

- The data contract between the plug-ins and core system are usually standard across a
    domain of plug-ins, and can be implemented as JSON, XML, or events passed between the
    plug-ins and core system.  Proprietary systems may implement their own contract structure.

- Common implementations of the plug-in architecture include:
    - IDEs
    - Web browsers
    - Tools like Jira and Jenkins
    - Insurance company software with a separate plug-in for each state
    - Tax preparation software with a separate plug-in for each state

- Strengths:
    - Simple and low cost
    - Can be both domain partitioned and technically partitioned
    - Good for platforms that require strong feature extensibility
    - More reliable since problems with a single plug-in won't crash entire system
    - Good modularity and extensibility

- Weaknesses:
    - Not scalable, elastic, or fault tolerant





