----------------------------------------------------
A - Relational Basics
----------------------------------------------------

- Reasons for using RDBMS

    1. Controlling redundancy
    2. Restricting access
    3. Persistent storage
    4. Efficient querying
    5. Backup and recovery
    6. Multiple user interfaces
    7. Complex relationships among data
    8. Enforcing integrity constraints
    9. Enforcing rules



- Relational Model Terminology

    - A relational schema R is made up of a name R and a list of attributes A1, A2, ... , An

    - The domain D of possible values in Ai is denoted dom(Ai)

    - The degree of a relation is the number of attributes in its schema

      # Here is a relation of degree 7
      STUDENT(Name, Ssn, Home_phone, Address, Office_phone, Age, Gpa)

    - A relation r of a relational schema R is a set of n-tuples.



- Sample Schema

    CREATE TABLE EMPLOYEE
        ( Fname             VARCHAR(15)       NOT NULL,
          Minit             CHAR,
          Lname             VARCHAR(15)       NOT NULL,
          Ssn               CHAR(9)           NOT NULL,
          Bdate             DATE,
          Address           VARCHAR(30),
          Sex               CHAR,
          Salary            DECIMAL(10,2),
          Super_ssn         CHAR(9),
          Dno               INT               NOT NULL,
        CONSTRAINT EMPLOYEE_PK PRIMARY KEY (Ssn),
        CONSTRAINT EMP_SUP_FK FOREIGN KEY (Super_ssn) REFERENCES EMPLOYEE(Ssn),
        CONSTRAINT EMP_DEPT_FK FOREIGN KEY (Dno) REFERENCES DEPARTMENT(Dnumber) );

    CREATE TABLE DEPARTMENT
        ( Dname             VARCHAR(15)       NOT NULL,
          Dnumber           INT               NOT NULL,
          Mgr_ssn           CHAR(9)           NOT NULL,
          Mgr_start_date    DATE,
        CONSTRAINT DEPARTMENT_PK PRIMARY KEY (Dnumber),
        UNIQUE (Dname),
        CONSTRAINT DEPT_EMP_FK FOREIGN KEY (Mgr_ssn) REFERENCES EMPLOYEE(Ssn) );

    CREATE TABLE DEPT_LOCATIONS
        ( Dnumber           INT               NOT NULL,
          Dlocation         VARCHAR(15)       NOT NULL,
        CONSTRAINT DEPT_LOCATIONS_PK PRIMARY KEY (Dnumber, Dlocation),
        CONSTRAINT LOC_DEPT_FK FOREIGN KEY (Dnumber) REFERENCES DEPARTMENT(Dnumber) );

    CREATE TABLE PROJECT
        ( Pname             VARCHAR(15)       NOT NULL,
          Pnumber           INT               NOT NULL,
          Plocation         VARCHAR(15),
          Dnum              INT               NOT NULL,
        CONSTRAINT PROJECT_PK PRIMARY KEY (Pnumber),
        UNIQUE (Pname),
        CONSTRAINT PROJ_DEPT_FK FOREIGN KEY (Dnum) REFERENCES DEPARTMENT(Dnumber) );

    CREATE TABLE WORKS_ON
        ( Essn              CHAR(9)           NOT NULL,
          Pno               INT               NOT NULL,
          Hours             DECIMAL(3,1)      NOT NULL,
        CONSTRAINT WORKS_ON_PK PRIMARY KEY (Essn, Pno),
        CONSTRAINT WORKS_EMP_FK FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn),
        CONSTRAINT WORKS_PROJ_FK FOREIGN KEY (Pno) REFERENCES PROJECT(Pnumber) );

    CREATE TABLE DEPENDENT
        ( Essn              CHAR(9)           NOT NULL,
          Dependent_name    VARCHAR(15)       NOT NULL,
          Sex               CHAR,
          Bdate             DATE,
          Relationship      VARCHAR(8),
        CONSTRAINT DEPENDENT_PK PRIMARY KEY (Essn, Dependent_name),
        CONSTRAINT DEPEND_EMP_FK FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn) );



- Naming Constraints

    Constraints can have a name for convenience, but they don't have to.

    # Valid
    PRIMARY KEY (Ssn)
    FOREIGN KEY (Superssn) REFERENCES EMPLOYEE (Ssn)


    # Also Valid
    CONSTRAINT EMPLOYEE_PK PRIMARY KEY (Ssn)
    CONSTRAINT EMP_SUP_FK FOREIGN KEY (Superssn) REFERENCES EMPLOYEE (Ssn)



- Setting Defaults

    # Set a default value for an attribute
    Mgr_ssn     CHAR(9)      NOT NULL       DEFAULT '9999999999'



- Check constraints

    # Set a check constraint for an attribute
    CHECK (D_NUM > 0 AND D_NUM < 21)



- Foreign Key Triggers

    - Referential integrity can be violated when tuples are deleted or inserted.  The default action that
        SQL takes for an integrity violation is to reject the update operation that will cause a violation.
        This is known as the RESTRICT option.


    - However, an alternative action can be specified by attaching a referential triggered action.  The
        options are:

        - SET NULL
        - CASCADE
        - SET DEFAULT

      An option must be qualified with:

        - ON DELETE
        - ON UPDATE


    - For instance, if the employee's supervisor is set as

        FOREIGN KEY (Superssn) REFERENCES EMPLOYEE (Ssn)
        ON DELETE SET NULL
        ON UPDATE CASCADE

      If the supervisor tuple is deleted, the value of 'Superssn' is set to NULL.
      If the supervisor tuple is updated, the value of 'Superssn' is set to the new value.


    - The ON DELETE CASCADE option means that if a tuple is deleted, all referencing tuples are deleted
        also.